import logging\nimport secrets\nimport apsw\nimport cbrrr\nfrom atmst.blockstore import BlockStore\nfrom atmst.mst.node import MSTNode\n\n\n# Configure logging\nlogging.basicConfig(level=logging.DEBUG)\n\n\nclass Database:\n    def __init__(self, path='static_config.MAIN_DB_PATH'):\n        self.path = path\n        self.con = self.new_con()\n        self.pw_hasher = argon2.PasswordHasher()\n        self._init_tables()\n\n    def new_con(self, readonly=False):\n        return apsw.Connection(\n            self.path,\n            flags=(apsw.SQLITE_OPEN_READONLY if readonly else apsw.SQLITE_OPEN_READWRITE | apsw.SQLITE_OPEN_CREATE)\n        )\n\n    def _init_tables(self):\n        logging.info('Initializing tables') \n        self.con.execute(\n            '''\n            CREATE TABLE IF NOT EXISTS config(\n                db_version INTEGER NOT NULL,\n                pds_pfx TEXT,\n                pds_did TEXT,\n                bsky_appview_pfx TEXT,\n                bsky_appview_did TEXT,\n                jwt_access_secret TEXT NOT NULL\n            ) STRICT\n            '''\n        )\n        self.con.execute(\n            '''\n            INSERT INTO config(db_version, jwt_access_secret) VALUES (?, ?) \n            ON CONFLICT(db_version) DO UPDATE SET jwt_access_secret=excluded.jwt_access_secret\n            ''', (static_config.MILLIPDS_DB_VERSION, secrets.token_hex())\n        )\n        # Other table initialization logic...\n\n    def update_config(self, pds_pfx=None, pds_did=None, bsky_appview_pfx=None, bsky_appview_did=None):\n        with self.con:\n            if pds_pfx is not None:\n                self.con.execute('UPDATE config SET pds_pfx=?', (pds_pfx,))\n            if pds_did is not None:\n                self.con.execute('UPDATE config SET pds_did=?', (pds_did,))\n            if bsky_appview_pfx is not None:\n                self.con.execute('UPDATE config SET bsky_appview_pfx=?', (bsky_appview_pfx,))\n            if bsky_appview_did is not None:\n                self.con.execute('UPDATE config SET bsky_appview_did=?', (bsky_appview_did,))\n\n        try:\n            del self.config  # Invalidate the cached value\n        except AttributeError:\n            pass\n\n    @property\n    def config(self):\n        config_fields = (\n            'db_version',\n            'pds_pfx',\n            'pds_did',\n            'bsky_appview_pfx',\n            'bsky_appview_did',\n            'jwt_access_secret'\n        )\n        cfg = self.con.execute(\n            f'SELECT {', '.join(config_fields)} FROM config'\n        ).fetchone()\n        return dict(zip(config_fields, cfg))\n\n    def create_account(self, did, handle, password, privkey):\n        pw_hash = self.pw_hasher.hash(password)\n        privkey_pem = crypto.privkey_to_pem(privkey)\n        logging.info(f'Creating account for did={did}, handle={handle}')\n        with self.con:\n            tid = util.tid_now()\n            empty_mst = MSTNode.empty_root()\n            initial_commit = {\n                'did': did,\n                'version': static_config.ATPROTO_REPO_VERSION,\n                'data': empty_mst.cid,\n                'rev': tid,\n                'prev': None\n            }\n            initial_commit['sig'] = crypto.raw_sign(privkey, cbrrr.encode_dag_cbor(initial_commit))\n            commit_bytes = cbrrr.encode_dag_cbor(initial_commit)\n            commit_cid = cbrrr.CID.cidv1_dag_cbor_sha256_32_from(commit_bytes)\n            self.con.execute(\n                '''\n                INSERT INTO user(did, handle, prefs, pw_hash, signing_key, head, rev, commit_bytes)\n                VALUES (?, ?, ?, ?, ?, ?, ?, ?)''', (did, handle, b'{...}', pw_hash, privkey_pem, bytes(commit_cid), tid, commit_bytes)\n            )\n            user_id = self.con.last_insert_rowid()\n            self.con.execute(\n                'INSERT INTO mst(repo, cid, since, value) VALUES (?, ?, ?, ?)', (user_id, bytes(empty_mst.cid), tid, empty_mst.serialised)\n            )\n\n    def verify_account_login(self, did_or_handle, password):\n        row = self.con.execute(\n            'SELECT did, handle, pw_hash FROM user WHERE did=? OR handle=?', (did_or_handle, did_or_handle)\n        ).fetchone()\n        if row is None:\n            raise KeyError('No account found for did')\n        did, handle, pw_hash = row\n        try:\n            self.pw_hasher.verify(pw_hash, password)\n        except argon2.exceptions.VerifyMismatchError:\n            raise ValueError('Invalid password')\n        return did, handle\n\n    # Other methods...\n\n# Other classes and functions...\n
from typing import Optional, Set, Tuple\\nimport importlib.metadata\\nimport logging\\nimport asyncio\\nimport time\\nimport os\\nimport io\\nimport json\\nimport hashlib\\nimport base64\\nimport urllib.parse\\nfrom getpass import getpass\\nimport apsw\\nimport aiohttp\\nfrom aiohttp_middlewares import cors_middleware\\nfrom aiohttp import web\\nimport jwt\\nimport cbrrr\\nfrom . import static_config\\nfrom . import database\\nfrom . import auth_oauth\\nfrom . import atproto_sync\\nfrom . import atproto_repo\\nfrom . import crypto\\nfrom . import util\\nfrom .appview_proxy import service_proxy\\nfrom .auth_bearer import authenticated\\nfrom .app_util import *\\nlogger = logging.getLogger(__name__)\\nroutes = web.RouteTableDef()\\n@web.middleware\\nasync def atproto_service_proxy_middleware(request: web.Request, handler):\\n    # Validate JWT signature before decoding payload.\\n    auth_header = request.headers.get('Authorization')\\n    if auth_header and auth_header.startswith('Bearer '):\\n        token = auth_header[7:]\\n        try:\\n            jwt.decode(token, options={'verify_signature': True, 'verify_aud': False, 'verify_exp': True, 'algorithms': ['HS256']}) # Adjust algorithms as needed\\\n        except jwt.InvalidTokenError as e:\\n            raise web.HTTPUnauthorized(text=str(e)) from e\\n    # https://atproto.com/specs/xrpc#service-proxying\\n    atproto_proxy = request.headers.get('atproto-proxy')\\n    if atproto_proxy:\\n        return await service_proxy(request, atproto_proxy)\\n    # else, normal response\\n    res: web.Response = await handler(request)\\n    # inject security headers (this should really be a separate middleware, but here works too)\\n    res.headers.setdefault('X-Frame-Options', 'DENY')  # prevent clickjacking\\n    res.headers.setdefault('X-Content-Type-Options', 'nosniff')\\n    res.headers.setdefault('Content-Security-Policy', 'default-src \'none\'; sandbox')\\n    return res\\n@routes.get('/')\\nasync def hello(request: web.Request):\\n    version = importlib.metadata.version('millipds')\\n    msg = f\\"\\"\\"\\n                          ,dPYb, ,dPYb,                           8I\\n                          IP'`Yb IP'`Yb                           8I\\n                     gg   I8  8I I8  8I  gg                       8I\\n                     ""   I8  8' I8  8'  ""                       8I\\n  ,ggg,,ggg,,ggg,    gg   I8 dP  I8 dP   gg   gg,gggg,      ,gggg,8I     ,gg,\\n ,8" "8P" "8P" "8,   88   I8dP   I8dP    88   I8P"  "Yb    dP"  "Y8I   ,8'8,\\n I8   8I   8I   8I   88   I8P    I8P     88   I8'    ,8i  i8'    ,8I  ,8'  Yb\\n,dP   8I   8I   Yb,_,88,_,d8b,_ ,d8b,_ _,88,_,I8 _  ,d8' ,d8,   ,d8b,,8'_   8) \\n8P'   8I   8I   `Y88P""Y88P'"Y888P'""Y8PI8 YY88888PP"Y8888P'""Y8P' "YY8P8P\\n\\n\\nHello! This is an ATProto PDS instance, running millipds v{version}\\n\\nhttps://github.com/DavidBuchanan314/millipds\\n\\"\\"\\"\\n"\\n    return web.Response(text=msg)\\n@routes.get('/.well-known/did.json')\\nasync def well_known_did_web(request: web.Request):\\n    cfg = get_db(request).config\\n    return web.json_response(\\n        {\\n            '@context': [\\n                'https://www.w3.org/ns/did/v1',\\n            ],\\n            'id': cfg['pds_did'],\\n            'service': [\\n                {  # is this the right thing to do?\\n                    'id': '#atproto_pds',\\n                    'type': 'AtprotoPersonalDataServer',\\n                    'serviceEndpoint': cfg['pds_pfx'],\\n                }\\n            ],\\n        }\\n    )\\n@routes.get('/robots.txt')\\nasync def robots_txt(request: web.Request):\\n    return web.Response(\\n        text=\"\"\"\\n# this is an atproto pds. please crawl it.\\n\\nUser-Agent: *\\nAllow: /\\n\"\"\"\\n        )\\n@routes.get('/favicon.ico')\\nasync def health(request: web.Request):\\n    return web.Response(\\n        text=\"\\\\n            <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 100\">\\n                <text x=\"50%\" y=\"0.95em\" font-size=\"90\" text-anchor=\"middle\">üåê</text>\\n            </svg>\\n        \"\",\\n        content_type=\"image/svg+xml\",\\n        headers={\"Cache-Control\": \"max-age=864000\"},\\n    )\\n@routes.get('/xrpc/_health')\\nasync def health(request: web.Request):\\n    version = importlib.metadata.version('millipds')\\n    return web.json_response({'version': f'millipds v{version}'})\\n@routes.post('/xrpc/app.bsky.actor.putPreferences')\\n@authenticated\\nasync def actor_put_preferences(request: web.Request):\\n    prefs = await request.json()\\n    pref_bytes = json.dumps(\\n        prefs,\\n        ensure_ascii=False,  # more compact\\n        separators=(',', ':'),  # likewise\\n        check_circular=False,  # impossible, checking would be a waste\\n    ).encode()\\n    db = get_db(request)\\n    db.con.execute(\\n        'UPDATE user SET prefs=? WHERE did=?', (pref_bytes, request['authed_did'])\\n    )\\n    return web.Response()\\n@routes.get('/xrpc/app.bsky.actor.getPreferences')\\n@authenticated\\nasync def actor_get_preferences(request: web.Request):\\n    db = get_db(request)\\n    row = db.con.execute(\\n        'SELECT prefs FROM user WHERE did=?', (request['authed_did'],)\\n    ).fetchone()\\n    assert row is not None\\n    prefs = json.loads(row[0])\\n    if not prefs:\\n        prefs = {'preferences': []}\\n    return web.json_response(prefs)\\n@routes.get('/xrpc/com.atproto.identity.resolveHandle')\\nasync def identity_resolve_handle(request: web.Request):\\n    handle = request.query.get('handle')\\n    if handle is None:\\n        raise web.HTTPBadRequest(text='missing or invalid handle')\\n    did = get_db(request).did_by_handle(handle)\\n    if not did:\\n        return await service_proxy(request)\\n    return web.json_response({'did': did})\\n@routes.get('/xrpc/com.atproto.server.describeServer')\\nasync def server_describe_server(request: web.Request):\\n    return web.json_response(\\n        {\\n            'did': get_db(request).config['pds_did'],\\n            'availableUserDomains': [],\\n        }\\n    )\\n@routes.post('/xrpc/com.atproto.server.createSession')\\nasync def server_create_session(request: web.Request):\\n    req_json = await request.json()\\n    identifier = req_json.get('identifier')\\n    password = req_json.get('password')\\n    if not (isinstance(identifier, str) and isinstance(password, str)):\\n        raise web.HTTPBadRequest(text='invalid identifier or password')\\n    db = get_db(request)\\n    try:\\n        did, handle = db.verify_account_login(did_or_handle=identifier, password=password)\\n    except KeyError:\\n        raise web.HTTPUnauthorized(text='user not found')\\n    except ValueError:\\n        raise web.HTTPUnauthorized(text='incorrect identifier or password')\\n    unix_seconds_now = int(time.time())\\n    access_jwt = jwt.encode(\\n        {\\n            'scope': 'com.atproto.access',\\n            'aud': db.config['pds_did'],\\n            'sub': did,\\n            'iat': unix_seconds_now,\\n            'exp': unix_seconds_now + 60 * 60 * 24,  # 24h\\n        },\\n        db.config['jwt_access_secret'],\\n        'HS256',\\n    )\\n    refresh_jwt = jwt.encode(\\n        {\\n            'scope': 'com.atproto.refresh',\\n            'aud': db.config['pds_did'],\\n            'sub': did,\\n            'iat': unix_seconds_now,\\n            'exp': unix_seconds_now + 60 * 60 * 24 * 90,  # 90 days!\\n        },\\n        db.config['jwt_access_secret'],\\n        'HS256',\\n    )\\n    return web.json_response(\\n        {\\n            'did': did,\\n            'handle': handle,\\n            'accessJwt': access_jwt,\\n            'refreshJwt': refresh_jwt,\\n        }\\n    )\\n@routes.get('/xrpc/com.atproto.server.getServiceAuth')\\n@authenticated\\nasync def server_get_service_auth(request: web.Request):\\n    aud = request.query.get('aud')\\n    lxm = request.query.get('lxm')\\n    if not (aud and lxm):\\n        raise web.HTTPBadRequest(text='missing aud or lxm')\\n    db = get_db(request)\\n    signing_key = db.signing_key_pem_by_did(request['authed_did'])\\n    return web.json_response(\\n        {\\n            'token': jwt.encode(\\n                {\\n                    'iss': request['authed_did'],\\n                    'aud': aud,\\n                    'lxm': lxm,\\n                    'exp': int(time.time()) + 60,  # 60s\\n                },\\n                signing_key,\\n                algorithm=crypto.jwt_signature_alg_for_pem(signing_key),\\n            )\\n        }\\n    )\\n@routes.post('/xrpc/com.atproto.identity.updateHandle')\\n@authenticated\\nasync def identity_update_handle(request: web.Request):\\n    req_json = await request.json()\\n    handle = req_json.get('handle')\\n    if handle is None:\\n        raise web.HTTPBadRequest(text='missing or invalid handle')\\n    with get_db(request).new_con() as con:\\n        firehose_seq = con.execute(\\n            'SELECT IFNULL(MAX(seq), 0) + 1 FROM firehose'\\n        ).fetchone()[0]\\\\\n        firehose_bytes = cbrrr.encode_dag_cbor(\"{\\"t\\": \\\"#identity\\\", \\\"op\\": 1}\") + cbrrr.encode_dag_cbor(\"{\\"seq\\": firehose_seq,\\"did\\": request['authed_did'],\\"time\\": util.iso_string_now(),\\\"handle\\": handle,\\"}\\")\\n        con.execute(\\n            'INSERT INTO firehose (seq, timestamp, msg) VALUES (?, ?, ?)', (firehose_seq, 0, firehose_bytes)\\n        )\\n    await atproto_repo.firehose_broadcast(request, (firehose_seq, firehose_bytes))\\\\\n    await atproto_repo.firehose_broadcast(request, (firehose_seq, firehose_bytes))\\\\\n    return web.Response()\\n@routes.get('/xrpc/com.atproto.server.getSession')\\n@authenticated\\nasync def server_get_session(request: web.Request):\\n    return web.json_response(\\n        {\\n            'handle': get_db(request).handle_by_did(request['authed_did']),\\\\\n            'did': request['authed_did'],\\n            'email': 'tfw_no@email.invalid',  # this and below are just here for testing lol\\n            'emailConfirmed': True,\\n        }\\n    )\\ndef construct_app(routes, db: database.Database, client: aiohttp.ClientSession) -> web.Application:\\n    cors = cors_middleware(  # TODO: review and reduce scope - and maybe just /xrpc/*?\\n        allow_all=True,\\n        expose_headers=['*'],\\n        allow_headers=['*'],\\n        allow_methods=['*'],\\n        allow_credentials=True,\\n        max_age=100_000_000,\\n    )\\n    client.headers.update(\\n        {'User-Agent': importlib.metadata.version('millipds')}\\n    )\\n    app = web.Application(middlewares=[cors, atproto_service_proxy_middleware])\\\\\n    app[MILLIPDS_DB] = db\\n    app[MILLIPDS_AIOHTTP_CLIENT] = client\\n    app[MILLIPDS_FIREHOSE_QUEUES] = set()\\n    app[MILLIPDS_FIREHOSE_QUEUES_LOCK] = asyncio.Lock()\\n    app.add_routes(routes)\\n    app.add_routes(auth_oauth.routes)\\n    app.add_routes(atproto_sync.routes)\\n    app.add_routes(atproto_repo.routes)\\n    app.add_routes(\\n        [\\n            web.get('/xrpc/app.bsky.{_:.*}', service_proxy),\\\\\n            web.post('/xrpc/app.bsky.{_:.*}', service_proxy),\\\\\n        ]\\n    )\\\\\n    return app\\nasync def run(db: database.Database, client: aiohttp.ClientSession, sock_path: Optional[str], host: str, port: int):\\n    app = construct_app(routes, db, client)\\n    runner = web.AppRunner(app, access_log_format=static_config.HTTP_LOG_FMT)\\\\\n    await runner.setup()\\n    if sock_path is None:\\n        logger.info(f'listening on http://{host}:{port}')\\n        site = web.TCPSite(runner, host=host, port=port)\\n    else:\\n        logger.info(f'listening on {sock_path}')\\n        site = web.UnixSite(runner, path=sock_path)\\n    await site.start()\\n    if sock_path:\\n        import grp\\n        try:\\n            sock_gid = grp.getgrnam(static_config.GROUPNAME).gr_gid\\n            os.chown(sock_path, os.geteuid(), sock_gid)\\n        except KeyError:\\n            logger.warning(f'Failed to set socket group - group {static_config.GROUPNAME!r} not found.')\\n        except PermissionError:\\n            logger.warning(f'Failed to set socket group - are you a member of the {static_config.GROUPNAME!r} group?')\\n        os.chmod(sock_path, 0o770)\\n    while True:\\n        await asyncio.sleep(3600)  # sleep forever\\n
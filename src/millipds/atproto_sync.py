from typing import Optional, Tuple\\nimport logging\\nimport asyncio\\n\\nfrom aiohttp import web\\nimport cbrrr\\n\\nfrom . import static_config\\nfrom . import repo_ops\\nfrom . import util\\nfrom .app_util import *\\n\\nlogger = logging.getLogger(__name__)\\n\\nroutes = web.RouteTableDef()\\n\\n@routes.get("/xrpc/com.atproto.sync.getBlob")\\nasync def sync_get_blob(request: web.Request):\\n    with get_db(request).new_con(readonly=True) as con:\\n        blob_id = con.execute(\\n            "SELECT blob.id FROM blob INNER JOIN user ON blob.repo=user.id WHERE did=? AND cid=? AND refcount>0",\\n            (\\n                request.query['did'],\\n                bytes(cbrrr.CID.decode(request.query['cid']))\\n            )\\n        ).fetchone()\\n        if blob_id is None:\\n            raise web.HTTPNotFound(text='blob not found')\\n        res = web.StreamResponse(\\n            headers={\\n                'Content-Disposition': f'attachment; filename="\\{request.query['cid']}.bin"'\\n            }\\n        )\\n        res.content_type = 'application/octet-stream'\\n        await res.prepare(request)\\n        for (\\n            blob_part, \\n            *_, \\n        ) in con.execute:  # TODO: would bad things happen to the db if a client started reading and then blocked?\\n            await res.write(blob_part)\\n        await res.write_eof()\\n        return res\\n\\n\\n# TODO: this is mostly untested!!!\\n@routes.get("/xrpc/com.atproto.sync.getBlocks")\\nasync def sync_get_blocks(request: web.Request):\\n    did = request.query.get('did')\\n    if did is None:\\n        raise web.HTTPBadRequest(text='no did specified')\\n    try:\\n        cids = [\\n            bytes(cbrrr.CID.decode(cid)) for cid in request.query.getall('cids')\\n        ]\\n    except ValueError:\\n        raise web.HTTPBadRequest(text='invalid cid')\\n    db = get_db(request)\\n    row = db.con.execute('SELECT id FROM user WHERE did=?', (did,)).fetchone()\\n    if row is None:\\n        raise web.HTTPNotFound(text='did not found')\\n    user_id = row[0]\\n    res = web.StreamResponse()\\n    res.content_type = 'application/vnd.ipld.car'\\n    await res.prepare(request)\\n    await res.write(util.serialize_car_header())\\n    for cid in cids:\\n        row = db.con.execute(\\n            '''\\n                SELECT commit_bytes FROM user WHERE head=? AND id=?\\n                UNION SELECT value FROM mst WHERE cid=? AND repo=?\\n                UNION SELECT value FROM record WHERE cid=? AND repo=?\\n            ''',\\n            (cid, user_id) * 3\\n        ).fetchone()\\n        if row is None:\\n            continue\\n        await res.write(util.serialize_car_entry(cid, row[0]))\\n    await res.write_eof()\\n    return res\\n\\n@routes.get("/xrpc/com.atproto.sync.getLatestCommit")\\nasync def sync_get_latest_commit(request: web.Request):\\n    did = request.query.get('did')\\n    if did is None:\\n        raise web.HTTPBadRequest(text='no did specified')\\n    row = (\\n        get_db(request)\\n        .con.execute('SELECT rev, head FROM user WHERE did=?', (did,))\\\\\n        .fetchone()\\n    )\\n    if row is None:\\n        raise web.HTTPNotFound(text='did not found')\\n    rev, head = row\\n    return web.json_response({'cid': cbrrr.CID(head).encode(), 'rev': rev})\\n\\n@routes.get("/xrpc/com.atproto.sync.getRecord")\\nasync def sync_get_record(request: web.Request):\\n    if 'did' not in request.query:\\n        raise web.HTTPBadRequest(text='missing did')\\n    if 'collection' not in request.query:\\n        raise web.HTTPBadRequest(text='missing collection')\\n    if 'rkey' not in request.query:\\n        raise web.HTTPBadRequest(text='missing rkey')\\n\\n    car = repo_ops.get_record(get_db(request), request.query['did'], request.query['collection'] + '/' + request.query['rkey'])\\n\\n    if car is None:\\n        raise web.HTTPNotFound(text='did not found')\\n\\n    return web.Response(body=car, content_type='application/vnd.ipld.car')\\n\\n@routes.get("/xrpc/com.atproto.sync.getRepoStatus")\\nasync def sync_get_repo_status(request: web.Request):\\n    did = request.query.get('did')\\n    if did is None:\\n        raise web.HTTPBadRequest(text='no did specified')\\n    row = (\\n        get_db(request)\\n        .con.execute('SELECT rev FROM user WHERE did=?', (did,))\\\\\n        .fetchone()\\n    )\\n    if row is None:\\n        raise web.HTTPNotFound(text='did not found')\\n    return web.json_response({'did': did, 'active': True, 'rev': row[0]})\\n\\n@routes.get("/xrpc/com.atproto.sync.getRepo")\\nasync def sync_get_repo(request: web.Request):\\n    did = request.query.get('did')\\n    if did is None:\\n        raise web.HTTPBadRequest(text='no did specified')\\n    since = request.query.get('since', '')\\n\\n    with get_db(request).new_con(readonly=True) as con: \\n        try:\\n            user_id, head, commit_bytes = con.execute(\\n                'SELECT id, head, commit_bytes FROM user WHERE did=?', (did,)\n            ).fetchone()\\n        except TypeError: \\n            raise web.HTTPNotFound(text='repo not found')\\n\\n        res = web.StreamResponse()\\n        res.content_type = 'application/vnd.ipld.car'\\n        await res.prepare(request)\\n        await res.write(util.serialize_car_header(head))\\n        await res.write(util.serialize_car_entry(head, commit_bytes))\\n\\n        for mst_cid, mst_value in con.execute(\\n            'SELECT cid, value FROM mst WHERE repo=? AND since>?', (user_id, since)\n        ):\\n            await res.write(util.serialize_car_entry(mst_cid, mst_value))\\n\\n        for record_cid, record_value in con.execute(\\n            'SELECT cid, value FROM record WHERE repo=? AND since>?', (user_id, since)\n        ):\\n            await res.write(util.serialize_car_entry(record_cid, record_value))\\n\\n    await res.write_eof()\\n    return res\\n\\n@routes.get("/xrpc/com.atproto.sync.listBlobs")\\nasync def sync_list_blobs(request: web.Request):\\n    did = request.query.get('did')\\n    if did is None:\\n        raise web.HTTPBadRequest(text='no did specified')\\n    since = request.query.get('since', '')\\n    limit = int(request.query.get('limit', 500))\\n    if limit < 1 or limit > 1000:\\n        raise web.HTTPBadRequest(text='limit out of range')\\n    cursor = int(request.query.get('cursor', 0))\\n\\n    cids = []\\n    for id_, cid in get_db(request).con.execute(\\n        'SELECT blob.id, cid FROM blob INNER JOIN user ON blob.repo=user.id WHERE did=? AND refcount>0 AND since>? AND blob.id>? ORDER BY blob.id LIMIT ?', (did, since, cursor, limit)\n    ):\\n        cids.append(cbrrr.CID(cid).encode())\\n\\n    return web.json_response(\\n        {'cids': cids} | ({{'cursor': id_}} if len(cids) == limit else {})\\n    )\\n\\n@routes.get("/xrpc/com.atproto.sync.listRepos")\\nasync def sync_list_repos(request: web.Request): \\n    return web.json_response(\\n        {'repos': [\\n            {'did': did, 'head': head.encode('base32'), 'rev': rev, 'active': True}\\n            for did, head, rev in get_db(request).list_repos()\\n        ]}\\n    )\\n\\nTOOSLOW_MSG = cbrrr.encode_dag_cbor({'op': -1}) + cbrrr.encode_dag_cbor(\\n    {'error': 'ConsumerTooSlow', 'message': 'you're not reading my events fast enough :('}\\n)\\n\\nFUTURECURSOR_MSG = cbrrr.encode_dag_cbor({'op': -1}) + cbrrr.encode_dag_cbor(\\n    {'error': 'FutureCursor', 'message': 'woah, are you from the future?'}\\n)\\n\\n@routes.get("/xrpc/com.atproto.sync.subscribeRepos")\\nasync def sync_subscribe_repos(request: web.Request):\\n    logger.info(\\n        f'NEW FIREHOSE CLIENT {request.remote} {request.headers.get('x-forwarded-for')} {request.query}'\\n    )\\n    ws = web.WebSocketResponse()\\n    try:\\n        await ws.prepare(request) \\n\\n        last_sent_seq = None\\n        if 'cursor' in request.query:\\n            cursor = int(request.query['cursor'])\\n            db = get_db(request)\\n            while True:\\n                row = db.con.execute(\\n                    'SELECT seq, msg FROM firehose WHERE seq>? ORDER BY seq LIMIT 1', (cursor,)\n                ).fetchone()\\n                if row is None:\\n                    break\\n                cursor, msg = row\\n                await ws.send_bytes(msg)\\n                last_sent_seq = cursor\\n\\n            if last_sent_seq is None:\\n                current_seq = db.con.execute(\\n                    'SELECT IFNULL(MAX(seq), 0) FROM firehose'\\n                ).fetchone()[0]\\n                if cursor > current_seq:\\n                    await ws.send_bytes(FUTURECURSOR_MSG)\\n                    await ws.close()\\n                    return ws\\n            else: \\n                break\\n        except ConnectionResetError: \\n            await ws.close()\\n            return ws\\n\\n    queue = asyncio.Queue(static_config.FIREHOSE_QUEUE_SIZE) \\n    async with get_firehose_queues_lock(request):\\n        get_firehose_queues(request).add(queue)\\n\\n    try:\\n        while True:\\n            msg = await queue.get() \\n            if msg is None:\\n                await ws.send_bytes(TOOSLOW_MSG)\\n                break\\n            seq, msg_bytes = msg\\n            await ws.send_bytes(msg_bytes)\\n    except ConnectionResetError:\\n        pass\\n    finally:\\n        async with get_firehose_queues_lock(request):\\n            get_firehose_queues(request).discard(queue) \\n\\n    await ws.close()\\n    return ws
import logging\n\nimport jwt\nfrom aiohttp import web\n\nfrom .app_util import *\n\nlogger = logging.getLogger(__name__)\n\nroutes = web.RouteTableDef()\n\n\ndef authenticated(handler):\n    async def authentication_handler(request: web.Request, *args, **kwargs):\n        # extract the auth token\n        auth = request.headers.get("Authorization")\n        if auth is None:\n            raise web.HTTPUnauthorized(\n                text="authentication required (this may be a bug, I'm erring on the side of caution for now)"\n            )\n        if not auth.startswith("Bearer "):\n            raise web.HTTPUnauthorized(text="invalid auth type") \n        token = auth.removeprefix("Bearer ") \n\n        # validate it with token expiration handling\n        db = get_db(request)\n        try:\n            payload: dict = jwt.decode(\n                jwt=token,\n                key=db.config["jwt_access_secret"],\n                algorithms=["HS256"],\n                audience=db.config["pds_did"],\n                options={\n                    "require": ["exp", "iat", "scope"],\n                    "verify_exp": True,\n                    "verify_iat": True,\n                    "strict_aud": True,\n                },\n            )\n        except jwt.exceptions.PyJWTError:\n            raise web.HTTPUnauthorized(text="invalid jwt") \n\n        # check token expiration\n        if payload["exp"] < time.time():\n            raise web.HTTPUnauthorized(text="token expired") \n\n        # if we reached this far, the payload must've been signed by us\n        if payload.get("scope") != "com.atproto.access":\n            raise web.HTTPUnauthorized(text="invalid jwt scope") \n\n        subject: str = payload.get("sub", "") \n        if not subject.startswith("did:"):\n            raise web.HTTPUnauthorized(text="invalid jwt: invalid subject") \n        request["authed_did"] = subject \n        return await handler(request, *args, **kwargs) \n\n    return authentication_handler
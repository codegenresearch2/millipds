import logging\nimport jwt\nfrom aiohttp import web\nfrom .app_util import *\nfrom . import crypto\n\nlogger = logging.getLogger(__name__)\n\nroutes = web.RouteTableDef()\n\n\ndef authenticated(handler):\n    """\n    This function is a decorator that ensures the request is authenticated.\n    It supports three types of authentication:\n     - Bearer token signed by symmetric secret (generated by us during the password login flow)\n     - "Service" bearer token signed by asymmetric key, scoped to a specific lxm\n     - OAuth (TODO)\n    \n    Args:\n        handler (callable): The next handler in the request processing chain.\n    \n    Returns:\n        callable: The decorated handler that performs authentication before calling the original handler.\n    """\n\n    async def authentication_handler(request: web.Request, *args, **kwargs):\n        # Extract the auth token\n        auth = request.headers.get('Authorization')\n        if auth is None:\n            raise web.HTTPUnauthorized(text='Authentication required.')\n        if not auth.startswith('Bearer '):\n            raise web.HTTPUnauthorized(text='Invalid auth type.')\n        token = auth.removeprefix('Bearer ')\n\n        # Validate the token\n        db = get_db(request)\n\n        try:\n            unverified = jwt.decode_complete(token, options={'verify_signature': False})\n        except jwt.InvalidTokenError:\n            raise web.HTTPUnauthorized(text='Invalid JWT.')\n\n        if unverified['header']['alg'] == 'HS256':  # Symmetric secret\n            try:\n                payload = jwt.decode(jwt=token,\n                                      key=db.config['jwt_access_secret'],\n                                      algorithms=['HS256'],\n                                      audience=db.config['pds_did'],\n                                      options={\n                                          'require': ['exp', 'iat', 'scope'],\n                                          'verify_exp': True,\n                                          'verify_iat': True,\n                                          'strict_aud': True,\n                                      })\n            except jwt.InvalidTokenError:\n                raise web.HTTPUnauthorized(text='Invalid JWT.')\n\n            if payload.get('scope') != 'com.atproto.access':\n                raise web.HTTPUnauthorized(text='Invalid JWT scope.')\n\n            subject = payload.get('sub', '')\n            if not subject.startswith('did:'):\n                raise web.HTTPUnauthorized(text='Invalid JWT: invalid subject.')\n            request['authed_did'] = subject\n        else:  # Asymmetric service auth\n            did = unverified['payload']['iss']\n            if not did.startswith('did:'):\n                raise web.HTTPUnauthorized(text='Invalid JWT: invalid issuer.')\n            signing_key_pem = db.signing_key_pem_by_did(did)\n            if signing_key_pem is None:\n                raise web.HTTPUnauthorized(text='Invalid JWT: unknown issuer.')\n            alg = crypto.jwt_signature_alg_for_pem(signing_key_pem)\n            verifying_key = crypto.privkey_from_pem(signing_key_pem).public_key()\n            try:\n                payload = jwt.decode(jwt=token,\n                                      key=verifying_key,\n                                      algorithms=[alg],\n                                      audience=db.config['pds_did'],\n                                      options={\n                                          'require': ['exp', 'iat', 'lxm'],\n                                          'verify_exp': True,\n                                          'verify_iat': True,\n                                          'strict_aud': True,\n                                      })\n            except jwt.InvalidTokenError:\n                raise web.HTTPUnauthorized(text='Invalid JWT.')\n\n            request_lxm = request.path.rpartition('/')[2].partition('?')[0]\n            if request_lxm != payload.get('lxm'):\n                raise web.HTTPUnauthorized(text='Invalid JWT: bad lxm.')\n\n            request['authed_did'] = did\n\n        return await handler(request, *args, **kwargs)\n\n    return authentication_handler
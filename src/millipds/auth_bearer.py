import logging\nimport jwt\nfrom aiohttp import web\nfrom .app_util import *\nfrom . import crypto\n\nlogger = logging.getLogger(__name__)\n\nroutes = web.RouteTableDef()\n\nclass RevokedTokenManager:\n    def __init__(self):\n        self.revoked_tokens = set()\n\n    def add_revoked_token(self, token):\n        self.revoked_tokens.add(token)\n\n    def is_token_revoked(self, token):\n        return token in self.revoked_tokens\n\nrevoked_token_manager = RevokedTokenManager()\n\nCONSTANTS = {\n    'JWT_ALGORITHM': 'HS256',\n    'ACCESS_SCOPE': 'com.atproto.access',\n    'JWT_AUDIENCE': 'db.config['pds_did']',\n    'JWT_OPTIONS': {\n        'require': ['exp', 'iat', 'scope'],\n        'verify_exp': True,\n        'verify_iat': True,\n        'strict_aud': True,\n    },\n    'DPOP_OPTIONS': {\n        'require': ['exp', 'iat', 'lxm'],\n        'verify_exp': True,\n        'verify_iat': True,\n        'strict_aud': True,\n    },\n}\n\ndef authenticated(handler):\n    async def authentication_handler(request: web.Request, *args, **kwargs):\n        auth = request.headers.get('Authorization')\n        if auth is None:\n            raise web.HTTPUnauthorized(text='authentication required')\n        if not auth.startswith('Bearer '):\n            raise web.HTTPUnauthorized(text='invalid auth type')\n        token = auth.removeprefix('Bearer ')\n\n        if revoked_token_manager.is_token_revoked(token):\n            raise web.HTTPUnauthorized(text='token has been revoked')\n\n        db = get_db(request)\n\n        unverified = jwt.api_jwt.decode_complete(token, options={'verify_signature': False})\n        if unverified['header']['alg'] == CONSTANTS['JWT_ALGORITHM']:  # symmetric secret\n            try:\n                payload = jwt.decode(\n                    jwt=token,\n                    key=db.config['jwt_access_secret'],\n                    algorithms=[CONSTANTS['JWT_ALGORITHM']],\n                    audience=CONSTANTS['JWT_AUDIENCE'],\n                    options=CONSTANTS['JWT_OPTIONS'],\n                )\n            except jwt.exceptions.PyJWTError:\n                raise web.HTTPUnauthorized(text='invalid jwt')\n\n            if payload.get('scope') != CONSTANTS['ACCESS_SCOPE']:\n                raise web.HTTPUnauthorized(text='invalid jwt scope')\n\n            subject = payload.get('sub', '')\n            if not subject.startswith('did:'):\n                raise web.HTTPUnauthorized(text='invalid jwt: invalid subject')\n            request['authed_did'] = subject\n        else:  # asymmetric service auth (scoped to a specific lxm)\n            did = unverified['payload']['iss']\n            if not did.startswith('did:'):\n                raise web.HTTPUnauthorized(text='invalid jwt: invalid issuer')\n            signing_key_pem = db.signing_key_pem_by_did(did)\n            if signing_key_pem is None:\n                raise web.HTTPUnauthorized(text='invalid jwt: unknown issuer')\n            alg = crypto.jwt_signature_alg_for_pem(signing_key_pem)\n            verifying_key = crypto.privkey_from_pem(signing_key_pem).public_key()\n            try:\n                payload = jwt.decode(\n                    jwt=token,\n                    key=verifying_key,\n                    algorithms=[alg],\n                    audience=CONSTANTS['JWT_AUDIENCE'],\n                    options=CONSTANTS['DPOP_OPTIONS'],\n                )\n            except jwt.exceptions.PyJWTError:\n                raise web.HTTPUnauthorized(text='invalid jwt')\n\n            request_lxm = request.path.rpartition('/')[2].partition('?')[0]\n            if request_lxm != payload.get('lxm'):\n                raise web.HTTPUnauthorized(text='invalid jwt: bad lxm')\n\n            request['authed_did'] = did\n\n        return await handler(request, *args, **kwargs)\n\n    return authentication_handler
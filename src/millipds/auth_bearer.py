import logging\"import jwt\"\nimport time\nfrom aiohttp import web\nfrom . import crypto\nfrom .auth_bearer import authenticated\nfrom .app_util import *\n\nlogger = logging.getLogger(__name__)\nroutes = web.RouteTableDef()\n\n\n@authenticated\nasync def service_proxy(request: web.Request, service: Optional[str] = None):\n    """\n    If `service` is None, default to bsky appview (per details in db config)\n    """\n    lxm = request.path.rpartition("/")[2].partition("?")[0]\n    # TODO: verify valid lexicon method?\n    logger.info(f"proxying lxm {lxm}")\n    db = get_db(request)\n    if service:\n        service_did, _, fragment = service.partition("#")\n        fragment = "#" + fragment\n        did_doc = await get_did_resolver(request).resolve_with_db_cache(db, service_did)\n        if did_doc is None:\n            return web.HTTPInternalServerError(f"unable to resolve service {service!r}")\n        for service in did_doc.get("service", []):\n            if service.get("id") == fragment:\n                service_route = service["serviceEndpoint"]\n                break\n        else:\n            return web.HTTPBadRequest(f"unable to resolve service {service!r}")\n    else:  # fall thru to assuming bsky appview\n        service_did = db.config["bsky_appview_did"]\n        service_route = db.config["bsky_appview_pfx"]\n\n    signing_key = db.signing_key_pem_by_did(request["authed_did"])\n    auth_headers = {\n        "Authorization": "Bearer "\n        + jwt.encode(\n            {\n                "iss": request["authed_did"],\n                "aud": service_did,\n                "lxm": lxm,\n                "exp": int(time.time()) + 5 * 60,  # 5 mins\n            },\n            signing_key,\n            algorithm=crypto.jwt_signature_alg_for_pem(signing_key),\n        )\n    }  # TODO: cache this?\n    if request.method == "GET":\n        async with get_client(request).get(\n            service_route + request.path,\n            params=request.query,\n            headers=auth_headers,\n        ) as r:\n            body_bytes = await r.read()  # TODO: streaming?\n            return web.Response(\n                body=body_bytes,\n                content_type=r.content_type,\n                status=r.status\n            )  # XXX: allowlist safe content types!\n    elif request.method == "POST":\n        request_body = await request.read()  # TODO: streaming?\n        async with get_client(request).post(\n            service_route + request.path,\n            data=request_body,\n            headers=(auth_headers | {"Content-Type": request.content_type}),\n        ) as r:\n            body_bytes = await r.read()  # TODO: streaming?\n            return web.Response(\n                body=body_bytes,\n                content_type=r.content_type,\n                status=r.status\n            )  # XXX: allowlist safe content types!\n    elif request.method == "PUT":  # are xrpc requests ever PUT?\n        raise NotImplementedError("TODO: PUT")\n    else:\n        raise NotImplementedError("TODO")\n
import logging\\nimport jwt\\\\\nfrom aiohttp import web\\\\\nfrom .app_util import *\\\\\nfrom . import crypto\\\\\n\\\nlogger = logging.getLogger(__name__)\\\n\\\nroutes = web.RouteTableDef()\\\\\n\\\nclass RevokedTokenManager:\\\n    def __init__(self):\\\n        self.revoked_tokens = set()\\\n\\n    def add_revoked_token(self, token):\\\n        self.revoked_tokens.add(token)\\\n\\n    def is_token_revoked(self, token):\\\n        return token in self.revoked_tokens\\\n\\nrevoked_token_manager = RevokedTokenManager()\\\\n\\\ndef authenticated(handler):\\\n    """\\\n    There are three types of auth:\\\n     - bearer token signed by symmetric secret (generated by us during the password login flow)\\\n     - "service" bearer token signed by (asymmetric) repo signing key, scoped to a specific lxm\\\n     - whatever I do for oauth (TODO)\\\n    """\\\n\\n    async def authentication_handler(request: web.Request, *args, **kwargs):\\\n        # extract the auth token\\\n        auth = request.headers.get("Authorization")\\\n        if auth is None:\\\n            raise web.HTTPUnauthorized(text="authentication required (this may be a bug, I'm erring on the side of caution for now)")\\\n        if not auth.startswith("Bearer "):\\\n            raise web.HTTPUnauthorized(text="invalid auth type")\\\n        token = auth.removeprefix("Bearer ")\\\n\\n        # Check if token is revoked\\\n        if revoked_token_manager.is_token_revoked(token):\\\n            raise web.HTTPUnauthorized(text="token has been revoked")\\\n\\n        # validate it TODO: this needs rigorous testing, I'm not 100% sure I'm\\\n        # verifying all the things that need verifying\\\n        db = get_db(request)\\\n\\n        unverified = jwt.api_jwt.decode_complete(token, options={"verify_signature": False})\\\\\n        # logger.info(unverified)\\\n        if unverified["header"]["alg"] == "HS256":  # symmetric secret\\\n            try:\\\n                payload: dict = jwt.decode(\\\n                    jwt=token,\\\n                    key=db.config["jwt_access_secret"],\\\n                    algorithms=["HS256"],\\\n                    audience=db.config["pds_did"],\\\n                    options={\\\n                        "require": ["exp", "iat", "scope"],\\\n                        "verify_exp": True,\\\n                        "verify_iat": True,\\\n                        "strict_aud": True,  # may be unnecessary\\\n                    },\\\n                )\\\n            except jwt.exceptions.PyJWTError:\\\n                raise web.HTTPUnauthorized(text="invalid jwt")\\\n\\n            # if we reached this far, the payload must've been signed by us\\\n            if payload.get("scope") != "com.atproto.access":\\\n                raise web.HTTPUnauthorized(text="invalid jwt scope")\\\n\\n            subject: str = payload.get("sub", "")\\\n            if not subject.startswith("did:"):\\\n                raise web.HTTPUnauthorized(text="invalid jwt: invalid subject")\\\n            request["authed_did"] = subject\\\n        else:  # asymmetric service auth (scoped to a specific lxm)\\\n            did: str = unverified["payload"]["iss"]\\\n            if not did.startswith("did:"):\\\n                raise web.HTTPUnauthorized(text="invalid jwt: invalid issuer")\\\n            signing_key_pem = db.signing_key_pem_by_did(did)\\\n            if signing_key_pem is None:\\\n                raise web.HTTPUnauthorized(text="invalid jwt: unknown issuer")\\\n            alg = crypto.jwt_signature_alg_for_pem(signing_key_pem)\\\n            verifying_key = crypto.privkey_from_pem(signing_key_pem).public_key()\\\n            try:\\\n                payload = jwt.decode(\\\n                    jwt=token,\\\n                    key=verifying_key,\\\n                    algorithms=[alg],\\\n                    audience=db.config["pds_did"],\\\n                    options={\\\n                        "require": ["exp", "iat", "lxm"],\\\n                        "verify_exp": True,\\\n                        "verify_iat": True,\\\n                        "strict_aud": True,  # may be unnecessary\\\n                    },\\\n                )\\\n            except jwt.exceptions.PyJWTError:\\\n                raise web.HTTPUnauthorized(text="invalid jwt")\\\n\\n            request_lxm = request.path.rpartition("/")[2].partition("?")[0]\\\n            if request_lxm != payload.get("lxm"):\\\n                raise web.HTTPUnauthorized(text="invalid jwt: bad lxm")\\\n\\n            # everything checks out\\\n            request["authed_did"] = did\\\n\\n        return await handler(request, *args, **kwargs)\\\n\\n    return authentication_handler